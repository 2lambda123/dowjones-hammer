import pytest

from . import mock_redshift
from library.aws.redshift import RedshiftClusterChecker
from library.aws.utility import Account

region = "us-east-1"

clusters = {
    "cluster1": {
        "DBName": "test1",
        "ClusterIdentifier": "test1",
        "ClusterType": "single-node",
        "NodeType": "ds2.xlarge",
        "MasterUsername": "user1",
        "MasterUserPassword": "testUser1password123",
        "Encrypted": True,
        "PubliclyAccessible": False,
        "CheckShouldPass": True
    },
    "cluster2": {
        "DBName": "test2",
        "ClusterIdentifier": "test2",
        "ClusterType": "single-node",
        "NodeType": "ds2.xlarge",
        "MasterUsername": "user2",
        "MasterUserPassword": "testUser2password123",
        "Encrypted": False,
        "PubliclyAccessible": False,
        "CheckShouldPass": False
    }
}


def find_cluster_name(cluster_details):
    for cluster, props in clusters.items():
        if props["ClusterIdentifier"] == cluster_details.name:
            return cluster
    return None


def ident_cluster_test(cluster_details):
    """
    Used to build identification string for each autogenerated test (for easy recognition of failed tests).

    :param cluster_details: dict with information about rules from
                        RedshiftClusterChecker(...)
    :return: identification string with cluster name.
    """

    name = find_cluster_name(cluster_details)
    descr = clusters.get(name, {}).get("Description", "default description")
    return f"params: {name} ({descr})"


def pytest_generate_tests(metafunc):
    """
    Entrypoint for tests (built-in pytest function for dynamic generation of test cases).
    """
    # Launch Redshift mocking and env preparation
    mock_redshift.start()
    test_clusters = mock_redshift.create_env_clusters(clusters, region)

    account = Account(region=region)

    # validate ebs volumes in mocked env
    checker = RedshiftClusterChecker(account)
    checker.check(ids=test_clusters)

    for cluster in checker.clusters:
        cluster.encrypt_cluster()

    checker_remediated = RedshiftClusterChecker(account)
    checker_remediated.check()

    redshift_clusters = [(cluster, False) for cluster in checker.clusters]
    redshift_clusters += [(cluster, True) for cluster in checker_remediated.clusters]

    # create test cases for each response
    metafunc.parametrize("cluster_details", redshift_clusters, ids=ident_cluster_test)


@pytest.mark.redshift_public_access
def test_cluster(cluster_details):
    """
    Actual testing function.

    :param cluster_details: dict with information about rules from
                        RedshiftClusterChecker(...)
    :return: nothing, raises AssertionError if actual test result is not matched with expected
    """
    name = find_cluster_name(cluster_details)
    expected = clusters.get(name, {})["CheckShouldPass"]
    assert expected == cluster_details.is_encrypt
